---
import BaseLayout from '../layouts/BaseLayout.astro';
import SearchInput from '../components/search/SearchInput.astro';
import SearchFilters from '../components/search/SearchFilters.astro';
import type { ContentType } from '../types/search';

const title = 'Buscar | OndaCoreana';
const description = 'Busca contenido sobre K-Dramas, K-Pop, noticias y guías de cultura coreana en español.';
const siteUrl = Astro.site?.toString().replace(/\/$/, '') || 'https://ondacoreana.com';
const allowedFilters: ContentType[] = ['all', 'dramas', 'kpop', 'noticias', 'guias'];

const url = Astro.url;
const rawQuery = url.searchParams.get('q') ?? '';
const normalizedQuery = rawQuery.trim().slice(0, 100);
const requestedFilter = (url.searchParams.get('type') ?? 'all') as ContentType;
const initialFilter = allowedFilters.includes(requestedFilter) ? requestedFilter : 'all';
const canonical = `${siteUrl}${url.pathname}${url.search}`;
const pageTitle = normalizedQuery ? `Buscar “${normalizedQuery}” | OndaCoreana` : title;
const shouldNoIndex = normalizedQuery.length === 0;
---

<BaseLayout title={pageTitle} description={description} noindex={shouldNoIndex} canonical={canonical} showSearch={false}>
  <main
    id="main-content"
    class="min-h-screen"
    style="background: color-mix(in srgb, var(--md-color-surface) 90%, var(--md-color-surface-container)); padding: var(--md-spacing-3xl) 0;"
    data-search-page
    data-initial-query={normalizedQuery}
    data-initial-filter={initialFilter}
  >
    <div class="mx-auto max-w-4xl px-4 sm:px-6 lg:px-8 space-y-8">
      {/* Page header */}
      <div class="space-y-3">
        <p class="chip" style="--chip-bg: color-mix(in srgb, var(--md-color-primary) 18%, transparent); --chip-color: var(--md-color-on-primary-container); width: fit-content;">
          Buscar
        </p>
        <h1 class="text-4xl font-bold" style="color: var(--md-color-on-surface); font-family: var(--md-typo-font-family);">
          Encuentra contenido de OndaCoreana
        </h1>
        <p class="text-lg" style="color: var(--md-color-on-surface-variant);">
          Explora reseñas de K-Dramas, perfiles de K-Pop, noticias y guías en un solo lugar.
        </p>
      </div>

      {/* Search input */}
      <div class="surface-card" style="padding: var(--md-spacing-xl); background: var(--md-color-surface-container-low);">
        <SearchInput
          placeholder="Buscar K-Dramas, K-Pop, noticias..."
          size="lg"
          initialValue={normalizedQuery}
          showInlineResults={false}
        />
        <p id="truncation-warning" class="hidden" style="margin-top: var(--md-spacing-sm); color: #b45309; font-size: var(--md-typo-label-medium-size);">
          La búsqueda se ha limitado a 100 caracteres.
        </p>
      </div>

      {/* Filter tabs */}
      <div class="surface-card" style="padding: var(--md-spacing-lg); background-color: var(--md-color-surface-container-low);">
        <SearchFilters activeFilter={initialFilter} query={normalizedQuery} />
      </div>

      {/* Results section - dynamically rendered by client-side JS */}
      <div
        id="search-results-container"
        class="space-y-4"
        aria-live="polite"
        aria-busy="true"
      ></div>
    </div>
  </main>
</BaseLayout>

<style>
  .search-results {
    display: flex;
    flex-direction: column;
    gap: var(--md-spacing-lg);
  }

  .result-count {
    font-size: var(--md-typo-body-medium-size);
    color: var(--md-color-on-surface-variant);
  }

  .search-result-card__link {
    display: flex;
    gap: var(--md-spacing-md);
    border-radius: var(--md-shape-xl);
    border: 1px solid color-mix(in srgb, var(--md-color-outline-variant) 80%, transparent);
    background-color: var(--md-color-surface-container-low);
    box-shadow: var(--md-elevation-1);
    transition: border-color var(--md-motion-duration-short) var(--md-motion-easing-standard), transform var(--md-motion-duration-short) var(--md-motion-easing-standard), box-shadow var(--md-motion-duration-short) var(--md-motion-easing-standard);
    padding: var(--md-spacing-md);
    color: inherit;
    text-decoration: none;
  }

  .search-result-card__link:hover {
    border-color: var(--md-color-primary);
    transform: translateY(-2px);
    box-shadow: var(--md-elevation-2);
  }

  .search-result-card__media img {
    border-radius: var(--md-shape-lg);
    object-fit: cover;
    width: 96px;
    height: 96px;
  }

  @media (max-width: 640px) {
    .search-result-card__media img {
      width: 72px;
      height: 72px;
    }
  }

  .search-result-chip {
    border-radius: var(--md-shape-full);
    padding: var(--md-spacing-xs) var(--md-spacing-sm);
    font-size: var(--md-typo-label-medium-size);
    font-weight: 600;
  }

  .search-result-chip[data-variant="dramas"] {
    background-color: var(--md-color-primary-container);
    color: var(--md-color-on-primary-container);
  }

  .search-result-chip[data-variant="kpop"] {
    background-color: var(--md-color-tertiary-container);
    color: var(--md-color-on-tertiary-container);
  }

  .search-result-chip[data-variant="noticias"] {
    background-color: var(--md-color-secondary-container);
    color: var(--md-color-on-secondary-container);
  }

  .search-result-chip[data-variant="guias"],
  .search-result-chip[data-variant="all"] {
    background-color: color-mix(in srgb, var(--md-color-primary) 12%, var(--md-color-surface-variant));
    color: var(--md-color-on-surface);
  }

  .search-result-title {
    font-size: var(--md-typo-title-medium-size);
    font-weight: 600;
    color: var(--md-color-on-surface);
    margin: 0;
  }

  .search-result-excerpt {
    font-size: var(--md-typo-body-medium-size);
    color: var(--md-color-on-surface-variant);
    margin: var(--md-spacing-xs) 0;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .search-result-date {
    font-size: var(--md-typo-label-medium-size);
    color: color-mix(in srgb, var(--md-color-on-surface-variant) 80%, transparent);
  }

  .search-empty {
    border-radius: var(--md-shape-xl);
    border: 1px dashed color-mix(in srgb, var(--md-color-outline) 80%, transparent);
    padding: var(--md-spacing-2xl);
    background-color: color-mix(in srgb, var(--md-color-surface-variant) 30%, transparent);
    text-align: center;
    color: var(--md-color-on-surface);
  }

  .search-empty h3 {
    font-size: var(--md-typo-title-medium-size);
    margin-bottom: var(--md-spacing-sm);
  }

  .search-empty p {
    color: var(--md-color-on-surface-variant);
  }

  .search-highlight {
    background-color: color-mix(in srgb, var(--md-color-primary) 25%, transparent);
    border-radius: var(--md-shape-sm);
    padding: 0 var(--md-spacing-xxs, 0.125rem);
  }

  #load-more-container {
    margin-top: var(--md-spacing-lg);
  }
</style>

<script>
  import { escapeHtml } from '../utils/search-client';
  import {
    renderLoadingState,
    renderEmptyState,
    renderMinLengthWarning,
    renderErrorState,
    renderLoadMoreButton,
    renderNoResults,
    renderResultCard,
    renderSearchResults,
    type SearchResultItem,
  } from '../utils/search-renderer';
  import { updateSEOMetaTags } from '../utils/search-seo';

  // Type definitions for client-side use
  type ContentType = 'all' | 'dramas' | 'kpop' | 'noticias' | 'guias';

  interface SearchResult extends SearchResultItem {
    relevanceScore: number;
  }

  // Pagefind types (inline for browser runtime)
  interface PagefindResultMeta {
    title?: string;
    description?: string;
    contentType?: string;
    pubDate?: string;
    heroImage?: string;
  }

  interface PagefindResultData {
    url: string;
    excerpt: string;
    meta: PagefindResultMeta;
  }

  interface PagefindResult {
    id: string;
    score: number;
    data: () => Promise<PagefindResultData>;
  }

  interface PagefindSearchResponse {
    results: PagefindResult[];
  }

  interface PagefindSearchOptions {
    filters?: Record<string, string | string[]>;
  }

  interface PagefindInstance {
    init: () => Promise<void>;
    search: (query: string, options?: PagefindSearchOptions) => Promise<PagefindSearchResponse>;
  }

  // Store pagefind instance globally
  let pagefindInstance: PagefindInstance | null = null;

  // Pagination state
  let currentSearchResults: PagefindResult[] = [];
  let currentQuery = '';
  let displayedCount = 0;
  const RESULTS_PER_PAGE = 10;

  // Get pagefind instance (lazy load once)
  async function getPagefind(): Promise<PagefindInstance> {
    if (!pagefindInstance) {
      const pagefindPath = '/pagefind/pagefind.js';
      const pf = await import(/* @vite-ignore */ pagefindPath) as PagefindInstance;
      await pf.init();
      pagefindInstance = pf;
    }
    return pagefindInstance!;
  }

  // Load more results (pagination)
  async function loadMoreResults(container: HTMLElement, query: string) {
    const startIndex = displayedCount;
    const endIndex = Math.min(startIndex + RESULTS_PER_PAGE, currentSearchResults.length);
    const hasMore = endIndex < currentSearchResults.length;

    // Load result data for the current page
    const resultsData = await Promise.all(
      currentSearchResults.slice(startIndex, endIndex).map((result) => result.data())
    );

    // Transform to our SearchResult type
    const results: SearchResult[] = resultsData.map((data, index) => ({
      title: data.meta?.title || 'Sin título',
      excerpt: data.excerpt || data.meta?.description || '',
      url: data.url,
      contentType: (data.meta?.contentType as ContentType) || 'all',
      pubDate: data.meta?.pubDate ? new Date(data.meta.pubDate) : new Date(),
      heroImage: data.meta?.heroImage,
      relevanceScore: currentSearchResults[startIndex + index]?.score || 0,
    }));

    displayedCount = endIndex;

    if (startIndex === 0) {
      // Initial render
      container.innerHTML = renderSearchResults(results, currentSearchResults.length, query, hasMore);
    } else {
      // Append more results
      const resultsContainer = container.querySelector('.space-y-4');
      if (resultsContainer) {
        resultsContainer.insertAdjacentHTML('beforeend', results.map(result => renderResultCard(result, query)).join(''));
      }
      // Update or remove load more button
      const loadMoreContainer = container.querySelector('#load-more-container');
      if (loadMoreContainer) {
        if (hasMore) {
          loadMoreContainer.innerHTML = renderLoadMoreButton();
        } else {
          loadMoreContainer.remove();
        }
      }
    }

    // Attach click handler to load more button
    const loadMoreBtn = container.querySelector('#load-more-btn');
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener('click', () => loadMoreResults(container, query));
    }
  }

  // Update filter tab active states
  function updateFilterActiveStates(activeType: ContentType) {
    const filterTabs = document.querySelectorAll('[data-testid="search-filters"] a');
    filterTabs.forEach((tab) => {
      const tabType = tab.getAttribute('data-filter-type') as ContentType;
      const isActive = tabType === activeType;
      tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
      tab.setAttribute('data-active', isActive ? 'true' : 'false');
    });
  }

  // Initialize search on page load
  async function initSearch() {
    const container = document.getElementById('search-results-container');
    // Use the search input specifically on the buscar page (in main-content)
    const searchInput = document.querySelector('#main-content [data-testid="site-search-input"]') as HTMLInputElement;
    const truncationWarning = document.getElementById('truncation-warning');

    if (!container) return;

    // Get query and filter from URL
    const urlParams = new URLSearchParams(window.location.search);
    let query = urlParams.get('q')?.trim() || '';
    const filterType = (urlParams.get('type') as ContentType) || 'all';

    // Update filter tab active states
    updateFilterActiveStates(filterType);

    // Check for truncation
    const wasQueryTruncated = query.length > 100;
    if (wasQueryTruncated) {
      query = query.substring(0, 100);
      truncationWarning?.classList.remove('hidden');
    }

    // Update search input with query value
    if (searchInput && query) {
      searchInput.value = query;
    }

    // Validate query (FR-016: min 2 non-whitespace chars)
    const isValidQuery = query.length >= 2;

    if (!isValidQuery) {
      // Update SEO for empty/invalid query
      updateSEOMetaTags(query, 0);

      if (query.length > 0) {
        // Invalid query (too short)
        container.innerHTML = renderMinLengthWarning();
      } else {
        // Empty query - show welcome state
        container.innerHTML = renderEmptyState();
      }
      return;
    }

    // Show loading state
    container.innerHTML = renderLoadingState();

    try {
      // Load Pagefind dynamically at runtime (not bundled by Vite)
      const pagefind = await getPagefind();

      // Perform search with optional filter
      const searchOptions: PagefindSearchOptions = {};
      if (filterType !== 'all') {
        searchOptions.filters = {
          contentType: filterType
        };
      }
      const search = await pagefind.search(query, searchOptions);

      // Store search results for pagination
      currentSearchResults = search.results;
      currentQuery = query;
      displayedCount = 0;

      // Update SEO meta tags with result count
      updateSEOMetaTags(query, search.results.length);

      // Load and render initial results
      if (search.results.length > 0) {
        await loadMoreResults(container, query);
      } else {
        container.innerHTML = renderNoResults(query);
      }
    } catch (error) {
      console.error('Search error:', error);
      container.innerHTML = renderErrorState();
      // Update SEO even on error (with 0 results)
      updateSEOMetaTags(query, 0);
    }
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSearch);
  } else {
    initSearch();
  }

  // Listen for filter changes (SPA-like navigation from SearchFilters)
  window.addEventListener('filterchange', () => {
    initSearch();
  });

  // Handle browser back/forward navigation
  window.addEventListener('popstate', () => {
    initSearch();
  });
</script>
